Z:\bmcdo020\Desktop\CEG3136\Lab2\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Mon Oct 16 14:58:10 2017

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =000024A4                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 27                          bsr inithw       ; initiliase the hardware
   35:     2005 16 235F                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 2494                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:     200B                        mainloop:                       ; {
   40:     200B CC 24AE                        ldd #MENU          ;   printf(MENU);
   41:     200E 15 FB CE76                     jsr [printf,PCr] 
   42:     2012 16 235F                        jsr initKeyPad     ;   select = readKey();
   43:     2015 17 00                          jsr readKey
   44:     2017 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   45:     2019 26 05                          bne mnElseif
   46:     201B 16 2062                        jsr configCodes
   47:     201E 20 09                          bra mnEndif
   48:     2020 C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   49:     2022 26 05                          bne mnElse
   50:     2024 16 21B9                        jsr enableAlarm
   51:     2027 20 00                          bra mnEndif
   52:     2029                        mnElse                     ;   else /*do nothing*/;
   53:     2029                        mnEndif:
   54:     2029 20 E0                          bra mainloop       ; } while(1);  // loop forever
   55:     202B 3F                             swi                ; never reach here - infinite loop
   56:                                 
   57:                                 ;------------------------------------------------------
   58:                                 ; Subroutine: inithw
   59:                                 ; No parameters
   60:                                 ; Variables: ptx - index register X
   61:                                 ;            pty - index register Y
   62:                                 ; Description: First setup up the microcontroller setting up the clock, 
   63:                                 ;             shutting down the COP watchdog timer, and initialising 
   64:                                 ;             the SCI serial interface. Initialises global variables also.
   65:                                 ;------------------------------------------------------
   66:     202C                        inithw:
   67:                                 ; -- Initialise the hardware
   68:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   69:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   70:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   71:                                 ;
   72:                                 ;       The math used to set the PLL frequency is:
   73:                                 ;        
   74:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   75:                                 ;       
   76:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   77:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   78:                                 ;         initREFDV    = 0    PLL divisor will be 1
   79:                                 
   80:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   81:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   82:                                 ;
   83:                                 ;      
   84:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   85:     202C 1410                           sei
   86:     202E CE 0000                        ldx #Regblk
   87:     2031 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   88:     2035 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   89:     2039 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   90:     203B 6A E0 34                       staa Synr,x
   91:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   92:     203E 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   93:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   94:     2040 6A E0 35                       staa Refdv,x
   95:     2043                        wait_b3:
   96:     2043 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   97:     2048 0C E0 39 80                    bset Clksel,x, %10000000
   98:                                 
   99:                                         ; Setup Serial port
  100:     204C CC 009C                        ldd #156
  101:     204F 5C C8                          std Sc0bdh   ; Sets up the baud rate
  102:     2051 86 0C                          ldaa #$0c
  103:     2053 5A CB                          staa Sc0cr2  ; Enables serial interface
  104:                                         
  105:                                         ; Setup the data in the RAM
  106:                                         ; For the Configuration Module
  107:     2055 1803 0000 3002                 movw #0,alarmCode
  108:     205B 1803 03E8 3000                 movw #1000,mult
  109:     2061 3D                             rts
  110:                                 
  111:                                    switch globalConst
  112:                                 
  113:                                 ;-------------------------------------------------------------------------
  114:                                 ; Data Structures
  115:                                 ; The following data is stored in EEPROM 
  116:                                 ; Following is data array used by testWin 
  117:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  118:                                 ;------------------------------------------------------
  119:     24A4 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           24AA FFFF FFFF 
  120:                                 
  121:                                 ; Message strings
  122:     24AE 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           24B4 36 20 41 6C 61 72 
           24BA 6D 0A 0D 63 2D 43 
           24C0 6F 6E 66 69 67 20 
           24C6 61 2D 41 72 6D 0A 
           24CC 0D 00 
  123:     24CE 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  124:                                 
  125:                                  
  126:                                 ;----------
  127:                                 ; Include other modules here
  128:                                 ;-----------
  129:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2062 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2063 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2065 16 20A8                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2068 97                           tsta
   33:     2069 27 39                        beq cfg_endif1
   34:     206B                        cfg_loop:               ;     do {
   35:     206B CC 24DF                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206E 15 FB CE16                   jsr [printf,PCr]
   37:     2072 17 00                        jsr readKey ;          input = readKey();
   38:     2074 6B 81                        stab CFG_INPUT,SP ;
   39:     2076 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     207A                        cfg_if2:
   41:     207A A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207C 81 61                        cmpa #'a'
   43:     207E 26 07                        bne cfg_elseif2
   44:     2080 86 00                        ldaa #0           ;               setcode(0);
   45:     2082 16 2106                      jsr setcode
   46:     2085 20 19                        bra cfg_endif2
   47:     2087                        cfg_elseif2:
   48:     2087 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     2089 25 0A                        blo cfg_else2
   50:     208B 81 34                        cmpa #'4'
   51:     208D 22 06                        bhi cfg_else2
   52:     208F 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2091 07 73                        bsr setcode           ;           setcode(ix); }
   54:     2093 20 0B                        bra cfg_endif2
   55:     2095                        cfg_else2:              ;           else      
   56:     2095 CC 24F2                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2098 15 FB CDEC                   jsr [printf,PCr]  ;
   58:     209C 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     20A0                        cfg_endif2:
   60:     20A0 E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A2 27 C7                        beq cfg_loop
   62:     20A4                        cfg_endif1:
   63:     20A4 1B 83                        leas CFG_VARSIZE,SP
   64:     20A6 3A                           puld
   65:     20A7 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A8 37                     enterMstCode pshb
   87:     20A9 34                        pshx
   88:     20AA 35                        pshy
   89:     20AB 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AD 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B1 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B6 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BB CC 24D1                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BE 15 FB CDC6                jsr [printf, PCr]
   98:     20C2 69 81                     clr EMC_I,SP
   99:     20C4                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C4 17 00                     jsr readKey                ; {
  101:     20C6 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20C8                        emc_if1:
  103:     20C8 180F                      tba
  104:     20CA 16 2476                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CD 97                        tsta
  106:     20CE 27 2E                     beq emc_endfor             ;         break;
  107:     20D0                        emc_else1:                    ;    else {
  108:     20D0 E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D2 C0 30                     subb #ASCII_CONV_NUM
  110:     20D4 87                        clra
  111:     20D5 ED 85                     ldy  EMC_MULT,SP
  112:     20D7 13                        emul
  113:     20D8 E3 83                     addd EMC_ALARMCODE,SP
  114:     20DA 6C 83                     std EMC_ALARMCODE,SP
  115:     20DC EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20DE CE 000A                   ldx #10
  117:     20E1 1810                      idiv
  118:     20E3 6E 85                     stx EMC_MULT,SP
  119:     20E5 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20E8 26 0B                     bne emc_endif2
  121:     20EA FC 24A4                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20ED AC 83                     cpd EMC_ALARMCODE,SP
  123:     20EF 26 04                     bne emc_endif3
  124:     20F1 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F5                        emc_endif3:
  126:     20F5                        emc_endif2:                   ;       }
  127:     20F5                        emc_endif1:                   ;    }
  128:     20F5 A6 81                     ldaa EMC_I,SP
  129:     20F7 42                        inca
  130:     20F8 6A 81                     staa EMC_I,SP
  131:     20FA 81 04                     cmpa #4
  132:     20FC 25 C6                     blo emc_for
  133:     20FE                        emc_endfor:                   ; }
  134:     20FE A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     2100 1B 87                     leas EMC_VARSIZE,SP
  136:     2102 31                        puly
  137:     2103 30                        pulx
  138:     2104 33                        pulb
  139:     2105 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2106 35                     setcode: pshy       ; {
  169:     2107 34                              pshx
  170:     2108 3B                              pshd
  171:     2109 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210B 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     2110 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2115 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     211A 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211C                        setc_loop:                    ; do {
  180:     211C CC 24FE                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     211F 15 FB CD65                   jsr [printf, PCr]
  182:     2123 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2125                        setc_for:                     ;      {
  184:     2125 17 00                        jsr readKey             ;         input = readKey();
  185:     2127 6B 83                        stab SETC_INPUT,SP
  186:     2129 C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212B 26 1C                        bne setc_elseif         ;         { 
  188:     212D A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     212F 81 00                        cmpa #0
  190:     2131 26 09                        bne setc_else2
  191:     2133 CC 250C                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2136 15 FB CD4E                   jsr [printf,PCr]
  193:     213A 20 0B                        bra setc_endif2
  194:     213C                        setc_else2                    ;            else {
  195:     213C 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2141 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2145 20 3E                        bra setc_endfor          ;                 break; 
  198:     2147                        setc_endif2                   ;             }
  199:     2147 20 33                        bra setc_endif          ;         }
  200:     2149                        setc_elseif:
  201:     2149 A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214B 16 2476                      jsr isdigit
  203:     214E 97                           tsta
  204:     214F 27 22                        beq setc_else
  205:     2151 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2153 C0 30                        subb #ASCII_CONV_NUM
  207:     2155 87                           clra
  208:     2156 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     2158 ED 88                        ldy SETC_MULT,SP
  210:     215A 13                           EMUL                    ; // Result digit*mult is in D
  211:     215B E3 86                        addd SETC_ALARMCODE,SP
  212:     215D 6C 86                        std SETC_ALARMCODE,SP
  213:     215F EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2161 CE 000A                      ldx #10
  215:     2164 1810                         idiv
  216:     2166 6E 88                        stx SETC_MULT,SP
  217:     2168 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216B 26 0F                        bne setc_endif          ;             
  219:     216D 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2171 20 09                        bra setc_endif          ;         }
  221:     2173                        setc_else:                    ;         else {
  222:     2173 CC 24F2                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2176 15 FB CD0E                   jsr [printf, PCr]
  224:     217A 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217C                        setc_endif:
  227:     217C A6 82                        ldaa SETC_I,SP
  228:     217E 42                           inca
  229:     217F 6A 82                        staa SETC_I,SP
  230:     2181 81 04                        cmpa #4
  231:     2183 25 A0                        blo setc_for 
  232:     2185                        setc_endfor:                       ;   }
  233:     2185 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     2187 26 93                        bne setc_loop
  235:     2189 A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218B 48                           lsla  ; double index value - 2 bytes/element
  237:     218C CE 24A4                      ldx #alarmCodes
  238:     218F 1A E4                        leax a,x
  239:     2191 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2193 07 06                        bsr writeToEE
  241:     2195 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     2197 3A                           puld                    ; restore registers
  243:     2198 30                           pulx
  244:     2199 31                           puly
  245:     219A 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219B 34                     writeToEE:  pshx
  262:     219C 3B                                 pshd
  263:     219D E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     219F 3B                                 pshd   ; save argument on stack
  265:     21A0 B7 54                              tfr x,d ; first argument passed in D
  266:     21A2 4B FB CD00                         call [writeEEByte, PCr]
  267:     21A6 30                                 pulx  ; remove argument
  268:     21A7 EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21A9 E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AB 3B                                 pshd  ; save argument on stack
  271:     21AC B7 54                              tfr x,d ; first argument passed in D
  272:     21AE C3 0001                            addd #1 ; address+1
  273:     21B1 4B FB CCF1                         call [writeEEByte, PCr]
  274:     21B5 30                                 pulx   ; remove argument
  275:     21B6 3A                                 puld   ; restore D
  276:     21B7 30                                 pulx   ; restore X
  277:     21B8 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     24D1 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           24D7 20 63 6F 64 65 0A 
           24DD 0D 00 
  281:     24DF 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           24E5 20 31 2D 34 3A 6F 
           24EB 74 68 65 72 0A 0D 
           24F1 00 
  282:     24F2 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           24F8 74 72 79 0A 0D 00 
  283:     24FE 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           2504 72 20 27 64 27 0A 
           250A 0D 00 
  284:     250C 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           2512 20 64 69 73 61 62 
           2518 6C 65 0A 0D 00 
  285:                                 
  130:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 15000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21B9 3B                     enableAlarm:  pshd
   40:     21BA 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BC CC 251D                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21BF 15 FB CCC5                jsr [printf, PCr]
   46:     21C3 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21C7                        eal_while1:
   48:     21C7 E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21C9 26 0D                     bne eal_endwhile1            ; {
   50:     21CB 17 00                     jsr readKey                  ;   input = readKey();
   51:     21CD 6B 80                     stab EAL_INPUT,SP
   52:     21CF 180F                      tba
   53:     21D1 16 2298                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D4 6A 81                     staa EAL_CODEVALID,SP
   55:     21D6 20 EF                     bra eal_while1
   56:     21D8                        eal_endwhile1                   ; }
   57:                                 
   58:     21D8 CC 2524                   ldd #ARMING                   ; printf(ARMING);
   59:     21DB 15 FB CCA9                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21DF CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E2 16 241E                   jsr setDelay
   63:     21E5 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21E9 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21ED                        eal_while2:                     ; while(!delayFlag) 
   66:     21ED E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21EF 26 27                     bne eal_endwhile2
   68:     21F1 16 2437                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F4 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21F6 17 00                     jsr pollreadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21F8 6B 80                     stab EAL_INPUT,SP
   72:     21FA 180F                      tba
   73:     21FC                        eal_if1:
   74:     21FC 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     21FE 27 08                     beq eal_blk1
   76:     2200 16 2476                   jsr isdigit
   77:     2203 97                        tsta
   78:     2204 26 02                     bne eal_blk1
   79:     2206 20 0E                     bra eal_endif1   
   80:     2208                        eal_blk1:                       ;    {
   81:     2208 A6 80                     ldaa EAL_INPUT,SP            
   82:     220A 16 2298                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     220D 6A 81                     staa EAL_CODEVALID,SP
   84:     220F                        eal_if2:
   85:     220F 97                        tsta                         ;        if(codeValid) 
   86:     2210 27 04                     beq eal_endif2
   87:     2212 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     2216                        eal_endif2:
   89:     2216                        eal_endif1:                     ;    }
   90:     2216 20 D5                     bra eal_while2               
   91:     2218                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     2218                        eal_if3:                        ; if(!codeValid)
   96:     2218 E7 81                     tst EAL_CODEVALID,SP
   97:     221A 26 07                     bne eal_endif3
   98:     221C CC 2535                   ldd #ARMED                   ;        printf(ARMED)
   99:     221F 15 FB CC65                jsr [printf, PCr]
  100:     2223                        eal_endif3:
  101:     2223                        eal_while3                      ;  while(!codeValid)
  102:     2223 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     2225 26 6D                     bne eal_endwhile3
  104:     2227 17 00                     jsr pollReadKey              ;    input = pollReadKey();
  105:     2229 6B 80                     stab EAL_INPUT,SP
  106:     222B 180F                      tba
  107:     222D                        eal_elseif
  108:     222D 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     222F 27 08                     beq eal_blk2
  110:     2231 16 2476                   jsr isdigit
  111:     2234 97                        tsta
  112:     2235 26 02                     bne eal_blk2
  113:     2237 20 08                     bra eal_elseifA  
  114:     2239                        eal_blk2:      
  115:     2239 A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     223B 07 5B                     bsr checkCode                
  117:     223D 6A 81                     staa EAL_CODEVALID,SP 
  118:     223F 20 51                     bra eal_endelseif    
  119:     2241                        eal_elseifA:
  120:     2241 16 24A0                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  121:     2244 84 01                     anda #%00000001
  122:     2246 27 3C                     beq eal_elseifB               ;   {
  123:     2248 CC 2545                   ldd #DISARMING                ;      printf(DISARMING);
  124:     224B 15 FB CC39                jsr [printf, PCr]
  125:     224F CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     2252 16 241E                   jsr setDelay
  127:     2255                        eal_while4:                      ;      while(!codeValid)
  128:     2255 A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     2257 26 29                     bne eal_endwhile4 
  130:     2259                        eal_if4:
  131:     2259 16 2437                   jsr pollDelay                 ;         if(pollDelay())
  132:     225C 97                        tsta  
  133:     225D 27 09                     beq eal_else4                 ;         { 
  134:     225F 16 2319                   jsr triggerAlarm              ;            triggerAlarm();
  135:     2262 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     2266 20 18                     bra eal_endif4                ;         }
  137:     2268                        eal_else4                        ;         else {
  138:     2268 17 00                     jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  139:     226A 6B 80                     stab EAL_INPUT,SP
  140:     226C                        eal_if5:
  141:     226C 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     226E 81 23                     cmpa #'#' 
  143:     2270 27 08                     beq eal_blk3
  144:     2272 16 2476                   jsr isdigit
  145:     2275 97                        tsta
  146:     2276 26 02                     bne eal_blk3
  147:     2278 20 06                     bra eal_endif5   
  148:     227A                        eal_blk3:  
  149:     227A A6 80                     ldaa EAL_INPUT,SP
  150:     227C 07 1A                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     227E 6A 81                     staa EAL_CODEVALID,SP 
  152:     2280                        eal_endif5:
  153:     2280                        eal_endif4:                     ;          }
  154:     2280 20 D3                     bra eal_while4
  155:     2282                        eal_endwhile4:                  ;        }
  156:     2282                        eal_endelseifA                  ;      }
  157:     2282 20 0E                     bra eal_endelseif;      
  158:     2284                        eal_elseifB:
  159:     2284 16 24A0                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  160:     2287 84 FE                     anda #%11111110              ;      
  161:     2289 27 07                     beq eal_endelseifB           ;      {
  162:     228B 16 2319                   jsr triggerAlarm             ;          triggerAlarm();
  163:     228E 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  164:     2292                        eal_endelseifB:                 ;      }
  165:                                    ;    // ignore all other input
  166:     2292                        eal_endelseif:
  167:     2292 20 8F                      bra eal_while3
  168:     2294                        eal_endwhile3                   ; }
  169:     2294 1B 83                      leas EAL_VARSIZE,SP
  170:     2296 3A                         puld
  171:     2297 3D                         rts
  172:                                 
  173:                                 
  174:                                 ;------------------------------------------------------
  175:                                 ; Subroutine: checkCode
  176:                                 ; Parameters: input - accumulator A
  177:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  178:                                 ;          accumulator A
  179:                                 ; Local Variables: retval - on stack
  180:                                 ; Global Variables:
  181:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  182:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  183:                                 ; Descriptions: Creates alarm code using digits entered until
  184:                                 ;               4 digits are seen. After 4th digit, see if
  185:                                 ;               alarm code is valid using isCodeValid().
  186:                                 ;------------------------------------------------------
  187:                                 ; Stack usage
  188:                                         OFFSET 0
  189:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  190:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  191:     0002                        CKC_VARSIZE
  192:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  193:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  194:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  195:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  196:                                 
  197:     2298 35                     checkCode: pshy
  198:     2299 34                        pshx
  199:     229A 37                        pshb
  200:     229B 1B 9E                     leas -CKC_VARSIZE,SP       
  201:                                                               ; static int mult = 1000; // current multiplier of digit
  202:                                                               ; static int alarmCode = 0;   // alarm code value
  203:     229D 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  204:     22A1 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  205:                                    
  206:     22A3 16 2476                   jsr isdigit                ; if(isdigit(input))
  207:     22A6 97                        tsta
  208:     22A7 27 36                     beq ckc_else               ; {
  209:     22A9 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  210:     22AB 80 30                     suba #ASCII_CONV_NUM
  211:     22AD 180E                      tab                        
  212:     22AF 87                        clra
  213:     22B0 FD 3000                   ldy mult
  214:     22B3 13                        emul                       ; //*mult - result in D
  215:     22B4 F3 3002                   addd alarmCode
  216:     22B7 7C 3002                   std alarmCode
  217:     22BA FC 3000                   ldd mult                   ;    mult = mult/10;
  218:     22BD CE 000A                   ldx #10
  219:     22C0 1810                      idiv
  220:     22C2 7E 3000                   stx mult
  221:     22C5 FC 3000                   ldd mult                   ;    if(mult == 0) 
  222:     22C8 26 13                     bne ckc_endif1             ;    {
  223:     22CA FC 3002                   ldd alarmcode              ;
  224:     22CD 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  225:     22CF 6A 81                     staa CKC_RETVAL,SP
  226:     22D1 CC 0000                   ldd #0                     ;       alarmCode = 0;
  227:     22D4 7C 3002                   std alarmCode 
  228:     22D7 CC 03E8                   ldd #1000                  ;       mult = 1000;
  229:     22DA 7C 3000                   std mult     
  230:     22DD                        ckc_endif1:                   ;     }
  231:     22DD 20 0C                     bra ckc_endif              ; }
  232:     22DF                        ckc_else:                     ; else {
  233:     22DF CC 0000                   ldd #0                     ;       alarmCode = 0;
  234:     22E2 7C 3002                   std alarmCode 
  235:     22E5 CC 03E8                   ldd #1000                  ;       mult = 1000;
  236:     22E8 7C 3000                   std mult                   ; }
  237:     22EB                        ckc_endif:
  238:                                    
  239:     22EB A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  240:                                    ; Restore registers and stack
  241:     22ED 1B 82                     leas CKC_VARSIZE,SP
  242:     22EF 33                        pulb
  243:     22F0 30                        pulx
  244:     22F1 31                        puly
  245:     22F2 3D                        rts      
  246:                                 
  247:                                 
  248:                                 ;------------------------------------------------------
  249:                                 ; Subroutine: isCodeValid
  250:                                 ; Parameters: alarmCode stored in register D
  251:                                 ; Local Variables
  252:                                 ;   ptr - pointer to array - in register X
  253:                                 ;   cnt, retval - on the stack.
  254:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  255:                                 ; Description: Checks to see if alarm code is in the
  256:                                 ;              alarmCodes array.
  257:                                 ;------------------------------------------------------
  258:                                 
  259:                                 ; Stack usage
  260:                                         OFFSET 0
  261:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  262:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  263:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  264:     0004                        CDV_VARSIZE:
  265:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  266:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  267:                                 
  268:     22F3 34                     isCodeValid: pshx
  269:     22F4 1B 9C                     leas -CDV_VARSIZE,SP
  270:     22F6 6C 80                     std CDV_ALARMCODE,SP
  271:                                    ; int *ptr;  // pointer to alarmCodes
  272:     22F8 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  273:     22FC 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  274:     2300 CE 24A4                   ldx #alarmCodes           ; ptr = alarmCodes;
  275:     2303                        cdv_while                    ; do
  276:     2303 EC 31                     ldd 2,X+                  ; {
  277:     2305 AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  278:     2307 26 06                     bne cdv_endif             ;    {
  279:     2309 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  280:     230D 20 04                     bra cdv_endwhile          ;      break;
  281:     230F                        cdv_endif:                   ;    }
  282:     230F 63 82                     dec CDV_CNT,SP            ;   cnt--;
  283:     2311 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  284:     2313                        cdv_endwhile:
  285:     2313 A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  286:                                    ; restore registers and stack
  287:     2315 1B 84                     leas CDV_VARSIZE,SP 
  288:     2317 30                        pulx
  289:     2318 3D                        rts
  290:                                 
  291:                                 ;----------------------------
  292:                                 ; Subroutine: triggerAlarm
  293:                                 ; Parameters: none
  294:                                 ; Returns: nothing
  295:                                 ; Local Variables: retval, dobel, input - on stack
  296:                                 ; Description: Repeatedly sends a bel character to the
  297:                                 ;              terminal until a valid alarm code is entered.
  298:                                 ;----------------------------
  299:                                 ; Stack usage
  300:                                         OFFSET 0
  301:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  302:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  303:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  304:     0004                        TRA_VARSIZE:
  305:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  306:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  307:                                 
  308:     2319 3B                     triggerAlarm: pshd
  309:     231A 1B 9C                     leas -TRA_VARSIZE,SP
  310:     231C 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  311:                                                              ; byte dobel;
  312:                                                              ; byte input;
  313:     2320                        tra_while:                   ; while(!done)
  314:     2320 E7 80                     tst TRA_DONE,SP         ; {
  315:     2322 26 37                     bne tra_endwhile
  316:     2324 C6 07                     ldb #BEL                  ;    putchar(BEL);
  317:     2326 87                        clra
  318:     2327 15 FB CB5B                jsr [putchar, PCr]
  319:     232B CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  320:     232E 16 241E                   jsr setDelay
  321:     2331 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  322:     2335                        tra_while2:                  ;    while(!doneInput) 
  323:     2335 E7 82                     tst TRA_DONEINPUT,SP      ;    {
  324:     2337 26 20                     bne tra_endwhile2
  325:     2339 16 2437                   jsr polldelay             ;       doneInput = delay();
  326:     233C 6A 82                     staa TRA_DONEINPUT,SP
  327:     233E 17 00                     jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  328:     2340 6B 83                     stab TRA_INPUT,SP
  329:     2342 180F                      tba
  330:     2344 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  331:     2346 27 08                     beq tra_blk1
  332:     2348 16 2476                   jsr isdigit
  333:     234B 97                        tsta
  334:     234C 26 02                     bne tra_blk1
  335:     234E 20 07                     bra tra_endif   
  336:     2350                        tra_blk1:
  337:     2350 A6 83                     ldaa TRA_INPUT,SP
  338:     2352 16 2298                   jsr checkCode             ;                done = checkCode(input);
  339:     2355 6A 80                     staa TRA_DONE,SP 
  340:     2357                        tra_endif: 
  341:     2357 20 DC                     bra tra_while2
  342:     2359                        tra_endwhile2                ;    }
  343:     2359 20 C5                     bra tra_while
  344:     235B                        tra_endwhile                 ; }
  345:     235B 1B 84                     leas TRA_VARSIZE,SP
  346:     235D 3A                        puld
  347:     235E 3D                        rts
  348:                                 
  349:                                 ;-------------------------------------------------------------------------
  350:                                 ; Data Structures
  351:                                 ;-------------------------------------------------------------------------
  352:                                         SWITCH globalConst
  353:                                 ; Message strings
  354:     251D 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           2523 00 
  355:     2524 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           252A 6D 69 6E 67 20 2A 
           2530 2A 2A 0A 0D 00 
  356:     2535 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           253B 6D 65 64 20 2A 2A 
           2541 2A 0A 0D 00 
  357:     2545 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           254B 61 72 6D 69 6E 67 
           2551 20 2D 2D 0A 0D 00 
  358:                                 
  359:                                    switch globalVar
  360:     3000 03E8                   mult dc.w 1000
  361:     3002 0000                   alarmCode dc.w 0
  131:                                  INCLUDE        keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 
   32:                                 ;-----Conversion table
   33:          =00000010              NUMKEYS EQU     16      ; Number of keys on the keypad
   34:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   35:          =00000000              NOKEY           EQU     $00   ; No key pressed during poll period
   36:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   37:          =00000000              COLS  EQU PORTA
   38:          =00000000              ROWS  EQU PORTA
   39:          =00000001              LED   EQU PORTB
   40:          =00000010              ROW0  EQU %00010000
   41:          =00000020              ROW1  EQU %00100000
   42:          =00000040              ROW2  EQU %01000000
   43:          =00000080              ROW3  EQU %10000000
   44:          =0000000F              COLM  EQU %00001111
   45:          =000000F0              ROWM  EQU %11110000
   46:                                 
   47:     3004 +0001                  PDELAY  RMB 1
   48:                                 
   49:     3005 31 32 33 41            KCODE0  FCB $31,$32,$33,$41    ;"123A"
   50:     3009 34 35 36 42            KCODE1  FCB $34,$35,$36,$42    ;"456B"
   51:     300D 37 38 39 43            KCODE2  FCB $37,$38,$39,$43    ;"789C"
   52:     3011 2A 30 23 44            KCODE3  FCB $2A,$30,$23,$44    ;"*0#D"
   53:                                  SWITCH globalConst  ; Constant data
   54:                                 
   55:                                 
   56:                                 
   57:                                  SWITCH code_section  ; place in code section
   58:                                 ;-----------------------------------------------------------    
   59:                                 ; Subroutine: initKeyPad
   60:                                 ;
   61:                                 ; Description: 
   62:                                 ;       Initiliases PORT A
   63:                                 ;-----------------------------------------------------------    
   64:     235F                        initKeyPad:        ;
   65:                                    ;STAA  DDRB         ;MAKE PORTB OUTPUT
   66:                                    ;lDAA  #$02         ;
   67:                                    ;STAA  DDRJ         ;ENABLE LED ARRAY ON PORTB OUTPUT
   68:                                    ;LDAA  #$00         ;
   69:                                    ;STAA  PTJ          ;
   70:     235F 79 0002                   CLR   DDRA
   71:     2362 86 FF                     LDAA  #$FF
   72:     2364 86 F0                     LDAA  #$F0         ;MAKE PORT A HIGH NIBLE OUTPUT
   73:     2366 5A 02                     STAA  DDRA         ;LOW NIBLE INPUT
   74:     2368 86 0F                     LDAA  #$0F         ;
   75:     236A 7A 025A                   STAA  DDRP
   76:                                 
   77:                                    ;STAA  PTP          ;TURN OFF 7SEG LED
   78:                                    ;LDAA  #$00         ;
   79:                                    ;STAA  PORTB        ;INITIALIZE PORT B
   80:                                 
   81:                                         
   82:     236D 3D                         rts
   83:                                 
   84:                                 ;-----------------------------------------------------------    
   85:                                 ; Subroutine: ch <- pollReadKey
   86:                                 ; Parameters: none
   87:                                 ; Local variable:
   88:                                 ; Returns
   89:                                 ;       ch: NOKEY when no key pressed,
   90:                                 ;       otherwise, ASCII Code in accumulator B
   91:                                 
   92:                                 ; Description:
   93:                                 ;  Loops for a period of 2ms, checking to see if
   94:                                 ;  key is pressed. Calls readKey to read key if keypress 
   95:                                 ;  detected (and debounced) on Port A and get ASCII code for
   96:                                 ;  key pressed.
   97:                                 ;-----------------------------------------------------------
   98:                                 ; Stack Usage
   99:                                         OFFSET 0  ; to setup offset into stack
  100:                                 
  101:     0000                        pollReadKey:                  ;TEST TO MAKE SURE NO BUTTON PRESSED
  102:     236E 86 F0                     LDAA  #ROWM        ;
  103:     2370 5A 00                     STAA  ROWS         ;SET ROWS HIGH
  104:     2372 96 00                     LDAA  COLS         ;CAPTURE PORT A
  105:     2374 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  106:     2376 81 00                     CMPA  #$00         ;
  107:     2378 1826 DC84                 LBNE  pollReadKey           ;IF COLUMS IS ZERO NO BUTTON PRESSED
  108:                                                       ;DO NOT MOVE ON UNTILL NO BUTTON IS PRESSED
  109:     237C                        debounce:
  110:     237C CC 0001                   LDD   #1                  ;
  111:     237F 16 2457                   JSR   delayms      ;CALL 15mS DELAY
  112:     2382 96 00                     LDAA  COLS         ;
  113:     2384 84 0F                     ANDA  #COLM        ;
  114:     2386 81 00                     CMPA  #$00         ;IF COLS !=0 THEN A BUTTON IS PRESSED
  115:     2388 26 02                     BNE   OVER         ;
  116:     238A 20 F0                     BRA   debounce           ;IF NO BUTTON PRESSED KEEP CHECKING
  117:     238C                        OVER:                 ;
  118:     238C 16 2457                   JSR   delayms      ;DEBOUCE DELAY
  119:     238F 96 00                     LDAA  COLS         ;READ PORT A
  120:     2391 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  121:     2393 81 00                     CMPA  #$00         ;CHECK FOR PRESS AFTER DEBOUNCE
  122:     2395 26 04                     BNE   OVER1        ;IF PRESSED GO FIND WHAT ROW
  123:     2397 1820 FFE1                 LBRA  debounce;IF NO PRESS G $200AFTER DEBOUNCE GO BACK
  124:     239B                        OVER1:                ;
  125:     239B 86 10                     LDAA  #ROW0        ;MAKE HIGH ROW0 THE REST GROUNDED
  126:     239D 5A 00                     STAA  ROWS         ;
  127:     239F 180B 08 3004              MOVB  #$08,PDELAY  ;SET COUNT TO PROVIDE SHORT DELAY FOR STABILITY
  128:     23A4 1820 DC58                 LBRA readKey
  129:     23A8 3D                        rts
  130:                                 
  131:                                 ;-----------------------------------------------------------    
  132:                                 ; Subroutine: ch <- readKey
  133:                                 ; Arguments: none
  134:                                 ; Local variable: 
  135:                                 ;       ch - ASCII Code in accumulator B
  136:                                 
  137:                                 ; Description:
  138:                                 ;  Main subroutine that reads a code from the
  139:                                 ;  keyboard using the subroutine readKeybrd.  The
  140:                                 ;  code is then translated with the subroutine
  141:                                 ;  translate to get the corresponding ASCII code.
  142:                                 ;-----------------------------------------------------------    
  143:                                 ; Stack Usage
  144:                                         OFFSET 0  ; to setup offset into stack
  145:                                 
  146:     0000                        readKey:             ;AFTER CHANGING THE PORT A OUTPUT
  147:     23A9 73 3004                   DEC   PDELAY       ;DECREMENT COUNT
  148:     23AC 1826 DC50                 LBNE   readKey ;IF COUNT NOT ZERO KEEP DECREMENTING
  149:     23B0 96 00                     LDAA  COLS         ;READ PORTA
  150:     23B2 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  151:     23B4 81 00                     CMPA  #$00         ;IS INPUT ZERO?
  152:     23B6 26 46                     BNE   R0           ;IF COLUMS NOT ZERO THEN BUTTON IS IN ROW 0
  153:     23B8 86 20                     LDAA  #ROW1        ;IF ZERO THEN BUTTON NOT IN ROW0
  154:     23BA 5A 00                     STAA  ROWS         ;TURN ON ROW 1 TURN OFF ALL OTHERS
  155:     23BC 180B 08 3004              MOVB  #$08,PDELAY  ;SHORT DELAY TO STABALIZE
  156:     23C1                        P2:                   ;AFTER CHANGING THE PORT A OUTPUT
  157:     23C1 73 3004                   DEC   PDELAY       ;DECREMENT COUNT
  158:     23C4 26 FB                     BNE   P2           ;IF COUNT NOT ZERO KEEP DECREMENTING
  159:     23C6 96 00                     LDAA  COLS         ;READ PORT A
  160:     23C8 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  161:     23CA 81 00                     CMPA  #$00         ;CHECK FOR KEY PRESS
  162:     23CC 26 35                     BNE   R1           ;IF PRESSED KEY IS IN ROW1
  163:     23CE 86 40                     LDAA  #ROW2        ;IF ZERO BUTTON NOT IN ROW1
  164:     23D0 5A 00                     STAA  ROWS         ;TURN ON ROW2 ALL OTHERS OFF
  165:     23D2 180B 08 3004              MOVB  #$08,PDELAY  ;SHORT DELAY TO STABALIZE PORTA
  166:     23D7                        P3:                   ;
  167:     23D7 73 3004                   DEC   PDELAY       ;DECREMENT COUNT
  168:     23DA 26 FB                     BNE   P3           ;DELAY LOOP
  169:     23DC 96 00                     LDAA  COLS         ;READ PORTA
  170:     23DE 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  171:     23E0 81 00                     CMPA  #$00         ;CHECK FOR PRESS
  172:     23E2 26 24                     BNE   R2           ;IF FOUND KEY IS IN ROW2
  173:     23E4 86 80                     LDAA  #ROW3        ;IF ZERO MOVE TO ROW3
  174:     23E6 5A 00                     STAA  ROWS         ;TURN ON ROW3 ALL OTHERS OFF
  175:     23E8 180B 08 3004              MOVB  #$08,PDELAY  ;SHORT DELAY TO STABALIZE OUTPUT
  176:     23ED                        P4:                   ;
  177:     23ED 73 3004                   DEC   PDELAY       ;DECREMENT DELAY
  178:     23F0 26 FB                     BNE   P4           ;DELAY LOOP
  179:     23F2 96 00                     LDAA  COLS         ;READ PORT A
  180:     23F4 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  181:     23F6 81 00                     CMPA  #$00         ;CHECK FOR PRESS
  182:     23F8 26 13                     BNE   R3           ;IF FOUND KEY IN ROW3
  183:     23FA 1820 FF7E                 LBRA   debounce           ;IF ROW NOT FOUND GO BACK TO START
  184:     23FE                        R0:                   ;
  185:     23FE CE 3005                   LDX   #KCODE0      ;LOAD PONTER TO ROW0 ARRAY
  186:     2401 20 0F                     BRA   FIND         ;GO FIND COLUMN
  187:     2403                        R1:                   ;
  188:     2403 CE 3009                   LDX   #KCODE1      ;LOAD POINTER TO ROW1 ARRAY
  189:     2406 20 0A                     BRA   FIND         ;GO FIND COUMN
  190:     2408                        R2:                   ;
  191:     2408 CE 300D                   LDX   #KCODE2      ;LOAD PINTER TO ROW2
  192:     240B 20 05                     BRA   FIND         ;GO FIND COLUMN
  193:     240D                        R3:                   ;
  194:     240D CE 3011                   LDX   #KCODE3      ;LOAD POINTER TO ROW3
  195:     2410 20 00                     BRA   FIND         ;GO FIND COLUMN
  196:     2412                        FIND:                 ;
  197:     2412 84 0F                     ANDA  #COLM        ;MASK OUT ROWS
  198:     2414 41                        COMA               ;INVERT COLUMN
  199:     2415                        SHIFT:                ;
  200:     2415 44                        LSRA               ;LOGICAL SHIFT RIGHT PORTA
  201:     2416 24 03                     BCC   MATCH        ;IF CARY CLEAR COLUM IS FOUND
  202:     2418 08                        INX                ;IF CARY NOT CLEAR INCREMENT POINTER TO ROW ARRAY
  203:     2419 20 FA                     BRA   SHIFT        ;SHIFT RIGHT UNTIL CARY IS CLEAR.
  204:     241B                        MATCH:                ;
  205:     241B E6 00                     LDAB  0,X          ;LOAD ASCII FROM ROW ARARAY    
  206:     241D 3D                         rts                    ;  return(ch); 
  207:                                 
  132:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Some definitions
   10:                                 
   11:                                         SWITCH code_section
   12:                                 
   13:                                 ;------------------------------------------------------
   14:                                 ; Subroutine setDelay
   15:                                 ; Parameters: cnt - accumulator D
   16:                                 ; Returns: nothing
   17:                                 ; Global Variables: delayCount
   18:                                 ; Description: Intialises the delayCount 
   19:                                 ;              variable.
   20:                                 ;------------------------------------------------------
   21:     241E                        setDelay: 
   22:     241E 7C 3015                   std delayCount
   23:     2421 3D                        rts
   24:                                 
   25:                                 
   26:                                 ;------------------------------------------------------
   27:                                 ; Subroutine: polldelay
   28:                                 ; Parameters:  none
   29:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   30:                                 ; Local Variables
   31:                                 ;   retval - acc A cntr - X register
   32:                                 ; Global Variables:
   33:                                 ;      delayCount
   34:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   35:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   36:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   37:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   38:                                 ;   Need 24 cyles to create 1 microsecond delay
   39:                                 ;   8 cycles creates a 333 1/3 nano delay
   40:                                 ;       DEX - 1 cycle
   41:                                 ;       BNE - 3 cyles - when branch is taken
   42:                                 ;       Need 4 NOP
   43:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   44:                                 ;------------------------------------------------------
   45:                                 ; Stack Usage:
   46:                                         OFFSET 0  ; to setup offset into stack
   47:          =00000011              D15mH EQU 17
   48:          =000000FA              D15mL EQU 250
   49:                                 
   50:     0000 +0001                  DR15mH  RMB 1
   51:     0001 +0001                  DR15mL  RMB 1
   52:                                 
   53:     0002                        PDLY_VARSIZE:
   54:     0002 +0002                  PDLY_PR_Y   DS.W 1 ; preserve Y
   55:     0004 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   56:     0006 +0001                  PDLY_PR_B   DS.B 1 ; preserve B
   57:     0007 +0002                  PDLY_RA     DS.W 1 ; return address
   58:                                 
   59:                                 
   60:     0009                        REALDELAY:                ;DELAY SUBROUTINE
   61:     2422 86 11                     LDAA  #D15mH       ;LOAD FIRST LAYER DELAY COUNT
   62:     2424 5A 00                     STAA  DR15mH       ;
   63:     2426                        D2:                   ;
   64:     2426 86 FA                     LDAA  #D15mL       ;LOAD SECOND LAYER DELAY COUNT
   65:     2428 5A 01                     STAA  DR15mL       ;
   66:     242A                        D1:                   ;
   67:     242A 73 0001                   DEC   DR15mL       ;DECREMENT SECOND LAYER COUNT
   68:     242D A7                        NOP                ;NOP DELAY
   69:     242E A7                        NOP                ;
   70:     242F 26 F9                     BNE   D1           ;BACK TO START OF SECOND LAYER IF NOT ZERO
   71:     2431 73 0000                   DEC   DR15mH       ;IF SECOND LAYER ZERO DECREMENT FIRST LAYER
   72:     2434 26 F0                     BNE   D2           ;IF FIRST LAYER NOT ZERO GO BACK RELOAD FRIST LAYER
   73:     2436 3D                        RTS                ;RETURN TO FROM SUBROUTINE WEHN LAYER ONE IS ZERO
   74:                                 
   75:     2437 37                     polldelay: pshb
   76:     2438 34                        pshx
   77:     2439 35                        pshy
   78:                                    ; Complete this routine
   79:     243A FD 3015                   ldy delayCount
   80:                                 
   81:     243D                        whileStart:
   82:     243D A7                        nop
   83:     243E A7                        nop
   84:     243F A7                        nop
   85:     2440 A7                        nop
   86:     2441 03                        dey
   87:     2442 26 F9                     bne whileStart
   88:     2444 FE 3015                   ldx delayCount
   89:     2447 09                        dex
   90:     2448 27 04                     beq complete
   91:     244A 86 00                     lda #FALSE
   92:     244C 20 02                     bra return
   93:     244E                        complete:
   94:     244E 86 01                     lda #TRUE
   95:     2450                        return:
   96:     2450 7E 3015                   stx delayCount
   97:                                 
   98:                                    ; restore registers and stack
   99:     2453 31                        puly
  100:     2454 30                        pulx
  101:     2455 33                        pulb
  102:     2456 3D                        rts
  103:                                 
  104:     2457 37                     delayms: pshb
  105:     2458 34                        pshx
  106:     2459 35                        pshy
  107:                                    ; Complete this routine
  108:     245A 3B                        pshd
  109:     245B 31                        puly
  110:                                 
  111:     245C                        whileStartms:
  112:     245C A7                        nop
  113:     245D A7                        nop
  114:     245E A7                        nop
  115:     245F A7                        nop
  116:     2460 03                        dey
  117:     2461 26 F9                     bne whileStartms
  118:     2463 FE 3015                   ldx delayCount
  119:     2466 09                        dex
  120:     2467 27 E5                     beq complete
  121:     2469 86 00                     lda #FALSE
  122:     246B 20 E3                     bra return
  123:     246D                        completems:
  124:     246D 86 01                     lda #TRUE
  125:     246F                        returnms:
  126:     246F 7E 3015                   stx delayCount
  127:                                 
  128:                                    ; restore registers and stack
  129:     2472 31                        puly
  130:     2473 30                        pulx
  131:     2474 33                        pulb
  132:     2475 3D                        rts
  133:                                 
  134:                                 ;------------------------------------------------------
  135:                                 ; Global variables
  136:                                 ;------------------------------------------------------
  137:                                    switch globalVar
  138:     3015 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  133:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     2476 37                     isdigit: pshb   ; save B on stack
   20:     2477 180E                      tab          ; save Parameter in B
   21:     2479 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     247B C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     247D 25 06                     blo ISD_endif
   24:     247F C1 39                     cmpb #'9'
   25:     2481 22 02                     bhi ISD_endif
   26:     2483 86 01                     ldaa #TRUE
   27:     2485                        ISD_endif:
   28:     2485 33                        pulb         ; restore B
   29:     2486 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     2487 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     2488 C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     248A 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     248E 15 FB C9F2               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     2492                        PGC_endif
   51:     2492 32                        pula            ; restore registers
   52:     2493 3D                        rts             ; return(chr);  in ACC B
  134:                                  INCLUDE        switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     2494                        initSwitches:        
   20:     2494 79 0262                   clr  DDRH         ; DDRH = 0; // set to input (switches)
   21:     2497 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   22:     249C 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   23:                                                      ;             // switches ground the pins when closed.
   24:     249F 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     24A0                        getSwStatus:
   36:     24A0 B6 0260                    ldaa PTH   ;return(PTH);
   37:     24A3 3D                         rts
  135:                                         
  136:                                    switch code_section
  137:     24A4                        ENDCODE ;  used to define where the dataEEPROM section starts
  138:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *000024a4
armdelay                        *00000bb8
armed                           *00002535
arming                          *00002524
ascii_conv_num                  *00000030
beepdelay                       *000003e8
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *0000230f
cdv_endwhile                    *00002313
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *00002303
cerrmsg                         *000024f2
cfg_else2                       *00002095
cfg_elseif2                     *00002087
cfg_endif1                      *000020a4
cfg_endif2                      *000020a0
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206b
cfg_varsize                     *00000003
checkcode                       *00002298
ckc_else                        *000022df
ckc_endif                       *000022eb
ckc_endif1                      *000022dd
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
codemsg                         *0000251d
colm                            *0000000f
cols                            *00000000
complete                        *0000244e
configcodes                     *00002062
configmsg                       *000024df
cr                              *0000000d
crgflg                          *00000037
d1                              *0000242a
d15mh                           *00000011
d15ml                           *000000fa
d2                              *00002426
ddra                            *00000002
ddrh                            *00000262
ddrp                            *0000025a
debounce                        *0000237c
delaycount                      *00003015
delayms                         *00002457
disarming                       *00002545
dr15mh                          *00000000
dr15ml                          *00000001
eal_blk1                        *00002208
eal_blk2                        *00002239
eal_blk3                        *0000227a
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *00002268
eal_elseifa                     *00002241
eal_elseifb                     *00002284
eal_endelseif                   *00002292
eal_endelseifb                  *00002292
eal_endif1                      *00002216
eal_endif2                      *00002216
eal_endif3                      *00002223
eal_endif4                      *00002280
eal_endif5                      *00002280
eal_endwhile1                   *000021d8
eal_endwhile2                   *00002218
eal_endwhile3                   *00002294
eal_endwhile4                   *00002282
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021c7
eal_while2                      *000021ed
eal_while3                      *00002223
eal_while4                      *00002255
emc_alarmcode                   *00000003
emc_endfor                      *000020fe
emc_endif2                      *000020f5
emc_endif3                      *000020f5
emc_for                         *000020c4
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021b9
endcode                         *000024a4
entermstcode                    *000020a8
err_mst_msg                     *0000250c
false                           *00000000
find                            *00002412
get_code_msg                    *000024fe
getchar                         *0000ee84
getswstatus                     *000024a0
inithw                          *0000202c
initkeypad                      *0000235f
initswitches                    *00002494
iscodevalid                     *000022f3
isd_endif                       *00002485
isdigit                         *00002476
kcode0                          *00003005
kcode1                          *00003009
kcode2                          *0000300d
kcode3                          *00003011
mainloop                        *0000200b
match                           *0000241b
menu                            *000024ae
mnelse                          *00002029
mnelseif                        *00002020
mnendif                         *00002029
mstcdmsg                        *000024d1
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
numcodes                        *00000005
over                            *0000238c
over1                           *0000239b
p2                              *000023c1
p3                              *000023d7
p4                              *000023ed
pdelay                          *00003004
perh                            *00000264
pgc_endif                       *00002492
pllctl                          *0000003a
polldelay                       *00002437
pollreadkey                     *00000000
porta                           *00000000
portb                           *00000001
ppsh                            *00000265
printf                          *0000ee88
program                         *00002000
pth                             *00000260
putchar                         *0000ee86
r0                              *000023fe
r1                              *00002403
r2                              *00002408
r3                              *0000240d
readkey                         *00000000
refdv                           *00000035
regblk                          *00000000
return                          *00002450
row0                            *00000010
row1                            *00000020
row2                            *00000040
row3                            *00000080
rowm                            *000000f0
rows                            *00000000
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002173
setc_else2                      *0000213c
setc_elseif                     *00002149
setc_endfor                     *00002185
setc_endif                      *0000217c
setc_endif2                     *00002147
setc_flag                       *00000001
setc_for                        *00002125
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211c
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002106
setdelay                        *0000241e
shift                           *00002415
stack                           *00002000
synr                            *00000034
tra_blk1                        *00002350
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *00002357
tra_endwhile                    *0000235b
tra_endwhile2                   *00002359
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *00002320
tra_while2                      *00002335
triggeralarm                    *00002319
true                            *00000001
variables                       *00003000
wait_b3                         *00002043
whilestart                      *0000243d
whilestartms                    *0000245c
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219b

