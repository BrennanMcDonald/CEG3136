Z:\bmcdo020\Desktop\Orig\alarmSimul.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Mon Oct 02 13:48:51 2017

    1:                                 
    2:                                 ;------------------------------------------------------
    3:                                 ; Alarm Simulation Assembler Program
    4:                                 ; File: alarmSimul.asm (Alarm System Simulation Module)
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
   11:                                 
   12:                                 ; Some definitions
   13:                                 ; Location of the register block
   14:          =00000000              Regblk:       equ    $0000 
   15:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00002500              VARIABLES EQU $2500  ; $2500 - $3FFF
   13:          =00000400              PROGRAM   EQU $0400  ; $0400 - $0FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00002500                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00000400                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =000007AD                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   16:                                  INCLUDE alarmSimul.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff    
   11:          =00000040              BEL           equ    '@'   ; 0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   17:                                 
   18:                                 ; Dbug12 subroutines
   19:          =0000EE86              putchar        equ   $EE86
   20:          =0000EE84              getchar        equ   $EE84
   21:          =0000EE88              printf         equ   $EE88
   22:          =0000EEA6              writeEEByte    equ   $EEA6
   23:                                 
   24:                                         switch code_section
   25:                                 ;------------------------------------------------------
   26:                                 ; Alarm Simulation Module
   27:                                 
   28:                                 ; Main routine
   29:                                 ; Variables: select - in register B (set by getchar)
   30:                                 ; Description: The main routine for running the game.
   31:                                 ;              Initialises things (via initgb) and the
   32:                                 ;              loops forever playing games.
   33:                                 ;------------------------------------------------------
   34:     0400 CF 2000                        lds #STACK       ; Not reflected in C
   35:     0403 07 22                          bsr inithw       ; initiliase the hardware
   36:                                         ; byte select - in register B
   37:                                                         ;do
   38:     0405                        mainloop:                       ; {
   39:     0405 CC 07B7                        ldd #MENU          ;   printf(MENU);
   40:     0408 15 FB EA7C                     jsr [printf,PCr] 
   41:     040C 15 FB EA74                     jsr [getchar,PCr]  ;   select = getchar();  // getchar is debug 12 routine
   42:     0410 37                             pshb ; save b
   43:     0411 33                             pulb
   44:     0412 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   45:     0414 26 05                          bne mnElseif
   46:     0416 16 045D                        jsr configCodes
   47:     0419 20 09                          bra mnEndif
   48:     041B C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   49:     041D 26 05                          bne mnElse
   50:     041F 16 05BD                        jsr enableAlarm
   51:     0422 20 00                          bra mnEndif
   52:     0424                        mnElse                     ;   else /*do nothing*/;
   53:     0424                        mnEndif:
   54:     0424 20 DF                          bra mainloop       ; } while(1);  // loop forever
   55:     0426 3F                             swi                ; never reach here - infinite loop
   56:                                 
   57:                                 ;------------------------------------------------------
   58:                                 ; Subroutine: inithw
   59:                                 ; No parameters
   60:                                 ; Variables: ptx - index register X
   61:                                 ;            pty - index register Y
   62:                                 ; Description: First setup up the microcontroller setting up the clock, 
   63:                                 ;             shutting down the COP watchdog timer, and initialising 
   64:                                 ;             the SCI serial interface. Initialises global variables also.
   65:                                 ;------------------------------------------------------
   66:     0427                        inithw:
   67:                                 ; -- Initialise the hardware
   68:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   69:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   70:                                 ;       In order to set the bus speed high than 4 MHz the PLL must be initialized
   71:                                 ;
   72:                                 ;       The math used to set the PLL frequency is:
   73:                                 ;        
   74:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   75:                                 ;       
   76:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   77:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   78:                                 ;         initREFDV    = 0    PLL divisor will be 1
   79:                                 
   80:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   81:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   82:                                 ;
   83:                                 ;      
   84:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   85:     0427 1410                           sei
   86:     0429 CE 0000                        ldx #Regblk
   87:     042C 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   88:     0430 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   89:     0434 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   90:     0436 6A E0 34                       staa Synr,x
   91:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   92:     0439 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   93:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   94:                                 
   95:     043B 6A E0 35                       staa Refdv,x
   96:     043E                        wait_b3:
   97:     043E 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   98:     0443 0C E0 39 80                    bset Clksel,x, %10000000
   99:                                 
  100:                                         ; Setup Serial port
  101:     0447 CC 009C                        ldd #156
  102:     044A 5C C8                          std Sc0bdh   ; Sets up the baud rate
  103:     044C 86 0C                          ldaa #$0c
  104:     044E 5A CB                          staa Sc0cr2  ; Enables serial interface
  105:                                         
  106:                                         ; Setup the data in the RAM
  107:                                         ; For the Configuration Module
  108:     0450 1803 0000 2502                 movw #0,alarmCode
  109:     0456 1803 03E8 2500                 movw #1000,mult
  110:     045C 3D                             rts
  111:                                 
  112:                                    switch globalConst
  113:                                 
  114:                                 ;-------------------------------------------------------------------------
  115:                                 ; Data Structures
  116:                                 ; The following data is stored in EEPROM 
  117:                                 ; Following is data array used by testWin 
  118:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  119:                                 ;------------------------------------------------------
  120:     07AD 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           07B3 FFFF FFFF 
  121:                                 
  122:                                 ; Message strings
  123:     07B7 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           07BD 36 20 41 6C 61 72 
           07C3 6D 0A 0D 63 2D 43 
           07C9 6F 6E 66 69 67 20 
           07CF 61 2D 41 72 6D 0A 
           07D5 0D 00 
  124:     07D7 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  125:                                 
  126:                                  
  127:                                 ;----------
  128:                                 ; Include other modules here
  129:                                 ;-----------
  130:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     045D 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     045E 1B 9D                        leas -CFG_VARSIZE,SP
   31:     0460 16 04A5                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     0463 97                           tsta
   33:     0464 27 3B                        beq cfg_endif1
   34:     0466                        cfg_loop:               ;     do {
   35:     0466 CC 07E8                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     0469 15 FB EA1B                   jsr [printf,PCr]
   37:     046D 15 FB EA13                   jsr [getchar,PCr] ;          input = getchar();
   38:     0471 6B 81                        stab CFG_INPUT,SP ;
   39:     0473 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     0477                        cfg_if2:
   41:     0477 A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     0479 81 61                        cmpa #'a'
   43:     047B 26 07                        bne cfg_elseif2
   44:     047D 86 00                        ldaa #0           ;               setcode(0);
   45:     047F 16 0505                      jsr setcode
   46:     0482 20 19                        bra cfg_endif2
   47:     0484                        cfg_elseif2:
   48:     0484 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     0486 25 0A                        blo cfg_else2
   50:     0488 81 34                        cmpa #'4'
   51:     048A 22 06                        bhi cfg_else2
   52:     048C 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     048E 07 75                        bsr setcode           ;           setcode(ix); }
   54:     0490 20 0B                        bra cfg_endif2
   55:     0492                        cfg_else2:              ;           else      
   56:     0492 CC 07FB                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     0495 15 FB E9EF                   jsr [printf,PCr]  ;
   58:     0499 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     049D                        cfg_endif2:
   60:     049D E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     049F 27 C5                        beq cfg_loop
   62:     04A1                        cfg_endif1:
   63:     04A1 1B 83                        leas CFG_VARSIZE,SP
   64:     04A3 3A                           puld
   65:     04A4 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     04A5 37                     enterMstCode pshb
   87:     04A6 34                        pshx
   88:     04A7 35                        pshy
   89:     04A8 1B 99                     leas -EMC_VARSIZE,SP
   90:     04AA 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     04AE 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     04B3 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     04B8 CC 07DA                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     04BB 15 FB E9C9                jsr [printf, PCr]
   98:     04BF 69 81                     clr EMC_I,SP
   99:     04C1                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     04C1 15 FB E9BF                jsr [getchar, PCr]         ; {
  101:     04C5 6B 82                     stab EMC_INPUT,SP          ;    input = getchar();
  102:     04C7                        emc_if1:
  103:     04C7 180F                      tba
  104:     04C9 16 078F                   jsr isdigit                ;    if(!isdigit(input))
  105:     04CC 97                        tsta
  106:     04CD 27 2E                     beq emc_endfor             ;         break;
  107:     04CF                        emc_else1:                    ;    else {
  108:     04CF E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     04D1 C0 30                     subb #ASCII_CONV_NUM
  110:     04D3 87                        clra
  111:     04D4 ED 85                     ldy  EMC_MULT,SP
  112:     04D6 13                        emul
  113:     04D7 E3 83                     addd EMC_ALARMCODE,SP
  114:     04D9 6C 83                     std EMC_ALARMCODE,SP
  115:     04DB EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     04DD CE 000A                   ldx #10
  117:     04E0 1810                      idiv
  118:     04E2 6E 85                     stx EMC_MULT,SP
  119:     04E4 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     04E7 26 0B                     bne emc_endif2
  121:     04E9 FC 07AD                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     04EC AC 83                     cpd EMC_ALARMCODE,SP
  123:     04EE 26 04                     bne emc_endif3
  124:     04F0 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     04F4                        emc_endif3:
  126:     04F4                        emc_endif2:                   ;       }
  127:     04F4                        emc_endif1:                   ;    }
  128:     04F4 A6 81                     ldaa EMC_I,SP
  129:     04F6 42                        inca
  130:     04F7 6A 81                     staa EMC_I,SP
  131:     04F9 81 04                     cmpa #4
  132:     04FB 25 C4                     blo emc_for
  133:     04FD                        emc_endfor:                   ; }
  134:     04FD A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     04FF 1B 87                     leas EMC_VARSIZE,SP
  136:     0501 31                        puly
  137:     0502 30                        pulx
  138:     0503 33                        pulb
  139:     0504 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     0505 35                     setcode: pshy       ; {
  169:     0506 34                              pshx
  170:     0507 3B                              pshd
  171:     0508 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     050A 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ; int digit;
  176:                                                               ; int mult;
  177:                                                               ; int alarmCode;
  178:     050F 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  179:     0514 6A 80                        staa SETC_IX,SP         ; save parameter value
  180:     0516                        setc_loop:                    ; do {
  181:     0516 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ;  alarmCode=0;
  182:     051B 1800 88 03E8                 movw #1000,SETC_MULT,SP ;      mult=1000;
  183:     0520 CC 0807                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  184:     0523 15 FB E961                   jsr [printf, PCr]
  185:     0527 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  186:     0529                        setc_for:                     ;      {
  187:     0529 15 FB E957                   jsr [getchar, PCr]      ;         input = getchar();
  188:     052D 6B 83                        stab SETC_INPUT,SP
  189:     052F C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  190:     0531 26 1C                        bne setc_elseif         ;         { 
  191:     0533 A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  192:     0535 81 00                        cmpa #0
  193:     0537 26 09                        bne setc_else2
  194:     0539 CC 0815                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  195:     053C 15 FB E948                   jsr [printf,PCr]
  196:     0540 20 0B                        bra setc_endif2
  197:     0542                        setc_else2                    ;            else {
  198:     0542 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  199:     0547 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  200:     054B 20 3E                        bra setc_endfor          ;                 break; 
  201:     054D                        setc_endif2                   ;             }
  202:     054D 20 33                        bra setc_endif          ;         }
  203:     054F                        setc_elseif:
  204:     054F A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  205:     0551 16 078F                      jsr isdigit
  206:     0554 97                           tsta
  207:     0555 27 22                        beq setc_else
  208:     0557 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  209:     0559 C0 30                        subb #ASCII_CONV_NUM
  210:     055B 87                           clra
  211:     055C 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  212:     055E ED 88                        ldy SETC_MULT,SP
  213:     0560 13                           EMUL                    ; // Result digit*mult is in D
  214:     0561 E3 86                        addd SETC_ALARMCODE,SP
  215:     0563 6C 86                        std SETC_ALARMCODE,SP
  216:     0565 EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  217:     0567 CE 000A                      ldx #10
  218:     056A 1810                         idiv
  219:     056C 6E 88                        stx SETC_MULT,SP
  220:     056E 8E 0000                      cpx #0                  ;            if(mult == 0)
  221:     0571 26 0F                        bne setc_endif          ;             
  222:     0573 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  223:     0577 20 09                        bra setc_endif          ;         }
  224:     0579                        setc_else:                    ;         else {
  225:     0579 CC 07FB                      ldd #CERRMSG            ;                printf(CERRMSG);
  226:     057C 15 FB E908                   jsr [printf, PCr]
  227:     0580 20 09                        bra setc_endfor         ;                break;
  228:                                                               ;         }
  229:     0582                        setc_endif:
  230:     0582 A6 82                        ldaa SETC_I,SP
  231:     0584 42                           inca
  232:     0585 6A 82                        staa SETC_I,SP
  233:     0587 81 04                        cmpa #4
  234:     0589 25 9E                        blo setc_for 
  235:     058B                        setc_endfor:                       ;   }
  236:     058B E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  237:     058D 26 87                        bne setc_loop
  238:     058F A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  239:     0591 48                           lsla  ; double index value - 2 bytes/element
  240:     0592 CE 07AD                      ldx #alarmCodes
  241:     0595 1A E4                        leax a,x
  242:     0597 EC 86                        ldd SETC_ALARMCODE,SP
  243:     0599 07 06                        bsr writeToEE
  244:     059B 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  245:     059D 3A                           puld                    ; restore registers
  246:     059E 30                           pulx
  247:     059F 31                           puly
  248:     05A0 3D                           rts
  249:                                 ;---------------------------------
  250:                                 ; Subroutine: writeToEE()
  251:                                 ; Parameters: address - in x register
  252:                                 ;             alarmCode    - in d register
  253:                                 ; Variables: none
  254:                                 ; Description:
  255:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  256:                                 ;     function avaible in Debug12.
  257:                                 ;------------------------------------------------------
  258:                                 ; Stack Usage
  259:                                         OFFSET 0 ; to setup offsets into stack
  260:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  261:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  262:     0004 +0002                  WREE_RA    DS.W 1       ; return address
  263:                                 
  264:     05A1 34                     writeToEE:  pshx
  265:     05A2 3B                                 pshd
  266:                                             ; Do the first byte
  267:     05A3 E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  268:     05A5 3B                                 pshd   ; save argument on stack
  269:     05A6 B7 54                              tfr x,d ; first argument passed in D
  270:     05A8 4B FB E8FA                         call [writeEEByte, PCr]
  271:     05AC 3A                                 puld  ; remove argument
  272:                                             ; Now for the second byte
  273:     05AD E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  274:     05AF 3B                                 pshd  ; save argument on stack
  275:     05B0 B7 54                              tfr x,d     ; get address - first argument passed in D
  276:     05B2 C3 0001                            addd #1 ; address+1
  277:     05B5 4B FB E8ED                         call [writeEEByte, PCr]
  278:     05B9 3A                                 puld   ; remove argument
  279:                                             ; All done - time to leave
  280:     05BA 3A                                 puld   ; restore D
  281:     05BB 30                                 pulx   ; restore X
  282:     05BC 3D                                 rts
  283:                                         
  284:                                    switch globalConst
  285:     07DA 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           07E0 20 63 6F 64 65 0A 
           07E6 0D 00 
  286:     07E8 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           07EE 20 31 2D 34 3A 6F 
           07F4 74 68 65 72 0A 0D 
           07FA 00 
  287:     07FB 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           0801 74 72 79 0A 0D 00 
  288:     0807 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           080D 72 20 27 64 27 0A 
           0813 0D 00 
  289:     0815 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           081B 20 64 69 73 61 62 
           0821 6C 65 0A 0D 00 
  290:                                 
  131:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 10000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     05BD 3B                     enableAlarm:  pshd
   40:     05BE 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     05C0 CC 0826                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     05C3 15 FB E8C1                jsr [printf, PCr]
   46:     05C7 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     05CB                        eal_while1:
   48:     05CB E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     05CD 26 0F                     bne eal_endwhile1            ; {
   50:     05CF 15 FB E8B1                jsr [getchar,PCr]              ;   input = getchar();
   51:     05D3 6B 80                     stab EAL_INPUT,SP
   52:     05D5 180F                      tba
   53:     05D7 16 06A3                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     05DA 6A 81                     staa EAL_CODEVALID,SP
   55:     05DC 20 ED                     bra eal_while1
   56:     05DE                        eal_endwhile1                   ; }
   57:                                 
   58:     05DE CC 082D                   ldd #ARMING                   ; printf(ARMING);
   59:     05E1 15 FB E8A3                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     05E5 CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     05E8 16 076B                   jsr setDelay
   63:     05EB 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     05EF 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     05F3                        eal_while2:                     ; while(!delayFlag) 
   66:     05F3 E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     05F5 26 28                     bne eal_endwhile2
   68:     05F7 16 076F                   jsr pollDelay                ;   delayFlag = pollDelay(); 
   69:     05FA 6A 82                     staa EAL_DELAYFLAG,SP
   70:     05FC 16 07A0                   jsr pollgetchar              ;   input = pollgetchar();  // check if code entered to disarm
   71:     05FF 6B 80                     stab EAL_INPUT,SP
   72:     0601 180F                      tba
   73:     0603                        eal_if1:
   74:     0603 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     0605 27 08                     beq eal_blk1
   76:     0607 16 078F                   jsr isdigit
   77:     060A 97                        tsta
   78:     060B 26 02                     bne eal_blk1
   79:     060D 20 0E                     bra eal_endif1   
   80:     060F                        eal_blk1:                       ;    {
   81:     060F A6 80                     ldaa EAL_INPUT,SP            
   82:     0611 16 06A3                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     0614 6A 81                     staa EAL_CODEVALID,SP
   84:     0616                        eal_if2:
   85:     0616 97                        tsta                         ;        if(codeValid) 
   86:     0617 27 04                     beq eal_endif2
   87:     0619 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     061D                        eal_endif2:
   89:     061D                        eal_endif1:                     ;    }
   90:     061D 20 D4                     bra eal_while2               
   91:     061F                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     061F                        eal_if3:                        ; if(!codeValid)
   96:     061F E7 81                     tst EAL_CODEVALID,SP
   97:     0621 26 07                     bne eal_endif3
   98:     0623 CC 083E                   ldd #ARMED                   ;        printf(ARMED)
   99:     0626 15 FB E85E                jsr [printf, PCr]
  100:     062A                        eal_endif3:
  101:     062A                        eal_while3                      ;  while(!codeValid)
  102:     062A E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     062C 26 71                     bne eal_endwhile3
  104:     062E 16 07A0                   jsr pollgetchar              ;    input = pollgetchar();b
  105:     0631 6B 80                     stab EAL_INPUT,SP
  106:     0633 180F                      tba
  107:     0635                        eal_elseif
  108:     0635 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     0637 27 08                     beq eal_blk2
  110:     0639 16 078F                   jsr isdigit
  111:     063C 97                        tsta
  112:     063D 26 02                     bne eal_blk2
  113:     063F 20 08                     bra eal_elseifA  
  114:     0641                        eal_blk2:      
  115:     0641 A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     0643 07 5E                     bsr checkCode                
  117:     0645 6A 81                     staa EAL_CODEVALID,SP 
  118:     0647 20 54                     bra eal_endelseif    
  119:     0649                        eal_elseifA:
  120:     0649 A6 80                     ldaa EAL_INPUT,SP             ;   else if(input == 'a') // Front door opened
  121:     064B 81 61                     cmpa #'a'
  122:     064D 26 3D                     bne eal_elseifB               ;   {
  123:     064F CC 084E                   ldd #DISARMING                ;      printf(DISARMING);
  124:     0652 15 FB E832                jsr [printf, PCr]
  125:     0656 CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     0659 16 076B                   jsr setDelay
  127:     065C                        eal_while4:                      ;      while(!codeValid)
  128:     065C A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     065E 26 2A                     bne eal_endwhile4 
  130:     0660                        eal_if4:
  131:     0660 16 076F                   jsr pollDelay                 ;         if(pollDelay())
  132:     0663 97                        tsta  
  133:     0664 27 09                     beq eal_else4                 ;         { 
  134:     0666 16 0724                   jsr triggerAlarm              ;            triggerAlarm();
  135:     0669 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     066D 20 19                     bra eal_endif4                ;         }
  137:     066F                        eal_else4                        ;         else {
  138:     066F 16 07A0                   jsr pollgetchar               ;            input = pollgetchar();  // check if alarm code entered to disarm
  139:     0672 6B 80                     stab EAL_INPUT,SP
  140:     0674                        eal_if5:
  141:     0674 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     0676 81 23                     cmpa #'#' 
  143:     0678 27 08                     beq eal_blk3
  144:     067A 16 078F                   jsr isdigit
  145:     067D 97                        tsta
  146:     067E 26 02                     bne eal_blk3
  147:     0680 20 06                     bra eal_endif5   
  148:     0682                        eal_blk3:  
  149:     0682 A6 80                     ldaa EAL_INPUT,SP
  150:     0684 07 1D                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     0686 6A 81                     staa EAL_CODEVALID,SP 
  152:     0688                        eal_endif5:
  153:     0688                        eal_endif4:                     ;          }
  154:     0688 20 D2                     bra eal_while4
  155:     068A                        eal_endwhile4:                  ;        }
  156:     068A                        eal_endelseifA                  ;      }
  157:     068A 20 11                     bra eal_endelseif;      
  158:     068C                        eal_elseifB:
  159:     068C A6 80                     ldaa EAL_INPUT,SP            ;      else if(input >='b' && input <= 'e') // other door/window opened
  160:     068E 81 62                     cmpa #'b'                    ;      {
  161:     0690 25 0B                     blo eal_endelseifB
  162:     0692 81 65                     cmpa #'e'
  163:     0694 22 07                     bhi eal_endelseifB
  164:     0696 16 0724                   jsr triggerAlarm             ;          triggerAlarm();
  165:     0699 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  166:     069D                        eal_endelseifB:                 ;      }
  167:                                    ;    // ignore all other input
  168:     069D                        eal_endelseif:
  169:     069D 20 8B                      bra eal_while3
  170:     069F                        eal_endwhile3                   ; }
  171:     069F 1B 83                      leas EAL_VARSIZE,SP
  172:     06A1 3A                         puld
  173:     06A2 3D                         rts
  174:                                 
  175:                                 
  176:                                 ;------------------------------------------------------
  177:                                 ; Subroutine: checkCode
  178:                                 ; Parameters: input - accumulator A
  179:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  180:                                 ;          accumulator A
  181:                                 ; Local Variables: retval - on stack
  182:                                 ; Global Variables:
  183:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  184:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  185:                                 ; Descriptions: Creates alarm code using digits entered until
  186:                                 ;               4 digits are seen. After 4th digit, see if
  187:                                 ;               alarm code is valid using isCodeValid().
  188:                                 ;------------------------------------------------------
  189:                                 ; Stack usage
  190:                                         OFFSET 0
  191:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  192:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  193:     0002                        CKC_VARSIZE
  194:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  195:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  196:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  197:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  198:                                 
  199:     06A3 35                     checkCode: pshy
  200:     06A4 34                        pshx
  201:     06A5 37                        pshb
  202:     06A6 1B 9E                     leas -CKC_VARSIZE,SP       
  203:                                                               ; static int mult = 1000; // current multiplier of digit
  204:                                                               ; static int alarmCode = 0;   // alarm code value
  205:     06A8 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  206:     06AC 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  207:                                    
  208:     06AE 16 078F                   jsr isdigit                ; if(isdigit(input))
  209:     06B1 97                        tsta
  210:     06B2 27 36                     beq ckc_else               ; {
  211:     06B4 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  212:     06B6 80 30                     suba #ASCII_CONV_NUM
  213:     06B8 180E                      tab                        
  214:     06BA 87                        clra
  215:     06BB FD 2500                   ldy mult
  216:     06BE 13                        emul                       ; //*mult - result in D
  217:     06BF F3 2502                   addd alarmCode
  218:     06C2 7C 2502                   std alarmCode
  219:     06C5 FC 2500                   ldd mult                   ;    mult = mult/10;
  220:     06C8 CE 000A                   ldx #10
  221:     06CB 1810                      idiv
  222:     06CD 7E 2500                   stx mult
  223:     06D0 FC 2500                   ldd mult                   ;    if(mult == 0) 
  224:     06D3 26 13                     bne ckc_endif1             ;    {
  225:     06D5 FC 2502                   ldd alarmcode              ;
  226:     06D8 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  227:     06DA 6A 81                     staa CKC_RETVAL,SP
  228:     06DC CC 0000                   ldd #0                     ;       alarmCode = 0;
  229:     06DF 7C 2502                   std alarmCode 
  230:     06E2 CC 03E8                   ldd #1000                  ;       mult = 1000;
  231:     06E5 7C 2500                   std mult     
  232:     06E8                        ckc_endif1:                   ;     }
  233:     06E8 20 0C                     bra ckc_endif              ; }
  234:     06EA                        ckc_else:                     ; else {
  235:     06EA CC 0000                   ldd #0                     ;       alarmCode = 0;
  236:     06ED 7C 2502                   std alarmCode 
  237:     06F0 CC 03E8                   ldd #1000                  ;       mult = 1000;
  238:     06F3 7C 2500                   std mult                   ; }
  239:     06F6                        ckc_endif:
  240:                                    
  241:     06F6 A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  242:                                    ; Restore registers and stack
  243:     06F8 1B 82                     leas CKC_VARSIZE,SP
  244:     06FA 33                        pulb
  245:     06FB 30                        pulx
  246:     06FC 31                        puly
  247:     06FD 3D                        rts      
  248:                                 
  249:                                 
  250:                                 ;------------------------------------------------------
  251:                                 ; Subroutine: isCodeValid
  252:                                 ; Parameters: alarmCode stored in register D
  253:                                 ; Local Variables
  254:                                 ;   ptr - pointer to array - in register X
  255:                                 ;   cnt, retval - on the stack.
  256:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  257:                                 ; Description: Checks to see if alarm code is in the
  258:                                 ;              alarmCodes array.
  259:                                 ;------------------------------------------------------
  260:                                 
  261:                                 ; Stack usage
  262:                                         OFFSET 0
  263:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  264:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  265:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  266:     0004                        CDV_VARSIZE:
  267:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  268:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  269:                                 
  270:     06FE 34                     isCodeValid: pshx
  271:     06FF 1B 9C                     leas -CDV_VARSIZE,SP
  272:     0701 6C 80                     std CDV_ALARMCODE,SP
  273:                                    ; int *ptr;  // pointer to alarmCodes
  274:     0703 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  275:     0707 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  276:     070B CE 07AD                   ldx #alarmCodes           ; ptr = alarmCodes;
  277:     070E                        cdv_while                    ; do
  278:     070E EC 31                     ldd 2,X+                  ; {
  279:     0710 AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  280:     0712 27 06                     beq cdv_endif             ;    {
  281:     0714 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  282:     0718 20 04                     bra cdv_endwhile          ;      break;
  283:     071A                        cdv_endif:                   ;    }
  284:     071A 63 82                     dec CDV_CNT,SP            ;   cnt--;
  285:     071C 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  286:     071E                        cdv_endwhile:
  287:     071E A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  288:                                    ; restore registers and stack
  289:     0720 1B 84                     leas CDV_VARSIZE,SP 
  290:     0722 30                        pulx
  291:     0723 3D                        rts
  292:                                 
  293:                                 ;----------------------------
  294:                                 ; Subroutine: triggerAlarm
  295:                                 ; Parameters: none
  296:                                 ; Returns: nothing
  297:                                 ; Local Variables: retval, dobel, input - on stack
  298:                                 ; Description: Repeatedly sends a bel character to the
  299:                                 ;              terminal until a valid alarm code is entered.
  300:                                 ;----------------------------
  301:                                 ; Stack usage
  302:                                         OFFSET 0
  303:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  304:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  305:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  306:     0004                        TRA_VARSIZE:
  307:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  308:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  309:                                 
  310:     0724 3B                     triggerAlarm: pshd
  311:     0725 1B 9C                     leas -TRA_VARSIZE,SP
  312:     0727 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  313:                                                              ; byte dobel;
  314:                                                              ; byte input;
  315:     072B                        tra_while:                   ; while(!done)
  316:     072B E7 80                     tst TRA_DONE,SP         ; {
  317:     072D 26 38                     bne tra_endwhile
  318:     072F C6 40                     ldab #BEL                 ;    putchar(BEL);
  319:     0731 87                        clra
  320:     0732 15 FB E750                jsr [putchar, PCr]
  321:     0736 CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  322:     0739 16 076B                   jsr setDelay
  323:     073C 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  324:     0740                        tra_while2:                  ;    while(!doneInput) 
  325:     0740 E7 82                     tst TRA_DONEINPUT,SP      ;    {
  326:     0742 26 21                     bne tra_endwhile2
  327:     0744 16 076F                   jsr pollDelay             ;       doneInput = pollDelay();
  328:     0747 6A 82                     staa TRA_DONEINPUT,SP
  329:     0749 16 07A0                   jsr pollgetchar           ;       input = pollgetchar();  // check if code entered to disarm
  330:     074C 6B 83                     stab TRA_INPUT,SP
  331:     074E 180F                      tba
  332:     0750 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  333:     0752 27 08                     beq tra_blk1
  334:     0754 16 078F                   jsr isdigit
  335:     0757 97                        tsta
  336:     0758 26 02                     bne tra_blk1
  337:     075A 20 07                     bra tra_endif   
  338:     075C                        tra_blk1:
  339:     075C A6 83                     ldaa TRA_INPUT,SP
  340:     075E 16 06A3                   jsr checkCode             ;                done = checkCode(input);
  341:     0761 6A 80                     staa TRA_DONE,SP 
  342:     0763                        tra_endif: 
  343:     0763 20 DB                     bra tra_while2
  344:     0765                        tra_endwhile2                ;    }
  345:     0765 20 C4                     bra tra_while
  346:     0767                        tra_endwhile                 ; }
  347:     0767 1B 84                     leas TRA_VARSIZE,SP
  348:     0769 3A                        puld
  349:     076A 3D                        rts
  350:                                 
  351:                                 ;-------------------------------------------------------------------------
  352:                                 ; Data Structures
  353:                                 ;-------------------------------------------------------------------------
  354:                                         SWITCH globalConst
  355:                                 ; Message strings
  356:     0826 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           082C 00 
  357:     082D 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           0833 6D 69 6E 67 20 2A 
           0839 2A 2A 0A 0D 00 
  358:     083E 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           0844 6D 65 64 20 2A 2A 
           084A 2A 0A 0D 00 
  359:     084E 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           0854 61 72 6D 69 6E 67 
           085A 20 2D 2D 0A 0D 00 
  360:                                 
  361:                                    switch globalVar
  362:     2500 03E8                   mult dc.w 1000
  363:     2502 0000                   alarmCode dc.w 0
  132:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Some definitions
   10:                                 
   11:                                         SWITCH code_section
   12:                                 
   13:                                 ;------------------------------------------------------
   14:                                 ; Subroutine setDelay
   15:                                 ; Parameters: cnt - accumulator D
   16:                                 ; Returns: nothing
   17:                                 ; Global Variables: delayCount
   18:                                 ; Description: Intialises the delayCount 
   19:                                 ;              variable.
   20:                                 ;------------------------------------------------------
   21:     076B                        setDelay: 
   22:     076B 7C 2504                   std delayCount;
   23:     076E 3D                        rts
   24:                                 
   25:                                 
   26:                                 ;------------------------------------------------------
   27:                                 ; Subroutine: polldelay
   28:                                 ; Parameters:  none
   29:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   30:                                 ; Local Variables
   31:                                 ;   retval - acc A cntr - X register
   32:                                 ; Global Variables:
   33:                                 ;      delayCount
   34:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   35:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   36:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   37:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   38:                                 ;   Need 24 cyles to create 1 microsecond delay
   39:                                 ;   8 cycles creates a 333 1/3 nano delay
   40:                                 ;       DEX - 1 cycle
   41:                                 ;       BNE - 3 cyles - when branch is taken
   42:                                 ;       Need 4 NOP
   43:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   44:                                 ;------------------------------------------------------
   45:                                 ; Stack Usage:
   46:                                         OFFSET 0  ; to setup offset into stack
   47:     0000                        PDLY_VARSIZE:
   48:     0000 +0002                  PDLY_PR_Y   DS.W 1 ; preserve Y
   49:     0002 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   50:     0004 +0001                  PDLY_PR_B   DS.B 1 ; preserve B
   51:     0005 +0002                  PDLY_RA     DS.W 1 ; return address
   52:                                 
   53:     076F 37                     polldelay: pshb
   54:     0770 34                        pshx
   55:     0771 35                        pshy
   56:                                    ; Complete this routine
   57:     0772 CD 2504                   ldy #delayCount
   58:                                 
   59:     0775                        whileStart
   60:     0775 A7                        nop
   61:     0776 A7                        nop
   62:     0777 A7                        nop
   63:     0778 A7                        nop
   64:     0779 03                        dey
   65:     077A 26 F9                     bne whileStart
   66:     077C FE 2504                   ldx delayCount
   67:     077F 09                        dex
   68:     0780 27 04                     beq complete
   69:     0782 86 00                     lda #FALSE
   70:     0784 20 02                     bra return
   71:     0786                        complete
   72:     0786 86 01                     lda #TRUE
   73:     0788                        return
   74:     0788 7E 2504                   stx delayCount
   75:                                 
   76:                                    ; restore registers and stack
   77:     078B 31                        puly
   78:     078C 30                        pulx
   79:     078D 33                        pulb
   80:     078E 3D                        rts
   81:                                 
   82:                                 
   83:                                 
   84:                                 ;------------------------------------------------------
   85:                                 ; Global variables
   86:                                 ;------------------------------------------------------
   87:                                    switch globalVar
   88:     2504 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  133:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     078F 37                     isdigit: pshb   ; save B on stack
   20:     0790 180E                      tab          ; save Parameter in B
   21:     0792 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     0794 C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     0796 25 06                     blo ISD_endif
   24:     0798 C1 39                     cmpb #'9'
   25:     079A 22 02                     bhi ISD_endif
   26:     079C 86 01                     ldaa #TRUE
   27:     079E                        ISD_endif:
   28:     079E 33                        pulb         ; restore B
   29:     079F 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     07A0 36                     pollgetchar: psha     ; gechar destroys contents of acc A
   46:     07A1 C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     07A3 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     07A7 15 FB E6D9               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     07AB                        PGC_endif
   51:     07AB 32                        pula            ; restore registers
   52:     07AC 3D                        rts             ; return(chr);  in ACC B
  134:                                 
  135:                                    switch code_section
  136:     07AD                        ENDCODE ;  used to define where the dataEEPROM section starts
  137:                                         end                ; end of program

Symbols:
alarmcode                       *00002502
alarmcodes                      *000007ad
armdelay                        *00000bb8
armed                           *0000083e
arming                          *0000082d
ascii_conv_num                  *00000030
beepdelay                       *000003e8
bel                             *00000040
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *0000071a
cdv_endwhile                    *0000071e
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *0000070e
cerrmsg                         *000007fb
cfg_else2                       *00000492
cfg_elseif2                     *00000484
cfg_endif1                      *000004a1
cfg_endif2                      *0000049d
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *00000466
cfg_varsize                     *00000003
checkcode                       *000006a3
ckc_else                        *000006ea
ckc_endif                       *000006f6
ckc_endif1                      *000006e8
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
codemsg                         *00000826
complete                        *00000786
configcodes                     *0000045d
configmsg                       *000007e8
cr                              *0000000d
crgflg                          *00000037
delaycount                      *00002504
disarming                       *0000084e
eal_blk1                        *0000060f
eal_blk2                        *00000641
eal_blk3                        *00000682
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *0000066f
eal_elseifa                     *00000649
eal_elseifb                     *0000068c
eal_endelseif                   *0000069d
eal_endelseifb                  *0000069d
eal_endif1                      *0000061d
eal_endif2                      *0000061d
eal_endif3                      *0000062a
eal_endif4                      *00000688
eal_endif5                      *00000688
eal_endwhile1                   *000005de
eal_endwhile2                   *0000061f
eal_endwhile3                   *0000069f
eal_endwhile4                   *0000068a
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000005cb
eal_while2                      *000005f3
eal_while3                      *0000062a
eal_while4                      *0000065c
emc_alarmcode                   *00000003
emc_endfor                      *000004fd
emc_endif2                      *000004f4
emc_endif3                      *000004f4
emc_for                         *000004c1
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000005bd
endcode                         *000007ad
entermstcode                    *000004a5
err_mst_msg                     *00000815
false                           *00000000
get_code_msg                    *00000807
getchar                         *0000ee84
inithw                          *00000427
iscodevalid                     *000006fe
isd_endif                       *0000079e
isdigit                         *0000078f
mainloop                        *00000405
menu                            *000007b7
mnelse                          *00000424
mnelseif                        *0000041b
mnendif                         *00000424
mstcdmsg                        *000007da
mult                            *00002500
nl                              *0000000a
nochar                          *000000ff
numcodes                        *00000005
pgc_endif                       *000007ab
pllctl                          *0000003a
polldelay                       *0000076f
pollgetchar                     *000007a0
printf                          *0000ee88
program                         *00000400
putchar                         *0000ee86
refdv                           *00000035
regblk                          *00000000
return                          *00000788
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00000579
setc_else2                      *00000542
setc_elseif                     *0000054f
setc_endfor                     *0000058b
setc_endif                      *00000582
setc_endif2                     *0000054d
setc_flag                       *00000001
setc_for                        *00000529
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *00000516
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00000505
setdelay                        *0000076b
stack                           *00002000
synr                            *00000034
tra_blk1                        *0000075c
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *00000763
tra_endwhile                    *00000767
tra_endwhile2                   *00000765
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *0000072b
tra_while2                      *00000740
triggeralarm                    *00000724
true                            *00000001
variables                       *00002500
wait_b3                         *0000043e
whilestart                      *00000775
wree_pr_d                       *00000000
writeeebyte                     *0000eea6
writetoee                       *000005a1

